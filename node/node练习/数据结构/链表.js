const a = { val: 'a' }
const b = { val: 'b' }
const c = { val: 'c' }
const d = { val: 'd' }
    // a的next属性指向b
a.next = b;
b.next = c;
c.next = d;
// 这个嵌套的object就相当于一个链表

//遍历链表
// 声明一个指针，指向a
let p = a
    // 当p还有值得时候
while (p) {
    console.log(p.val)
        // 不断得让p指向下一个位置
    p = p.next
}

// 在链表中插入值
const f = { val: 'f' }
c.next = f
f.next = d

// 删除值
c.next = d


// 遍历链表就是跟着链表从链表的头元素（head）一直走到尾元素（但是不包含链表的头借点，头通常用来作为链表的接入点）
// 还有一个问题，链表的尾元素指向一个null节点




// 删除上一个节点的指针即可，但是无法获取上一个节点的指针，因为链表中的节点只会指向下一个节点
// 怎么在不知道上一个节点指针的情况下还能删除呢？
// 将被删除的节点转移到下一个节点
// 也就是将下一个节点删除，但是要在删除之前将下一个节点的值转移到这个节点
var deleteNode = function(node) {
    node.val = node.next.val;
    node.next = node.next.next;
};
// 没有循环所以时间复杂度是O(1)
// 没有数组或者矩阵所以空间复杂度也是O(1)


// 反转链表
// 先考虑反转两个节点
// 将n+1的next指针指向n即可
// 反转多个节点就是用两个指针遍历列表即可，重复上面的操作即可
// 新建两个指针，一前一后遍历链表
// 不断反转双指针

// 如何让自己在世界上消失，但又不死？ —— 将自己完全变成另一个人，再杀了那个人就行了。